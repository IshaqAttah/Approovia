---
kind: pipeline
type: docker
name: microservices-deployment

# Global environment variables
environment:
  REGISTRY_HOST: 192.168.253.133:5000
  WG2_HOST: 192.168.253.128
  WG3_HOST: 192.168.253.135

steps:
  # Step 1: Run unit tests for service-a
  - name: test-service-a
    image: golang:1.21-alpine
    commands:
      - cd services/service-a
      - go mod download
      - go test -v ./...
      - go test -race -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html
    volumes:
      - name: test-cache
        path: /go/pkg

  # Step 2: Run unit tests for service-b  
  - name: test-service-b
    image: golang:1.21-alpine
    commands:
      - cd services/service-b
      - go mod download
      - go test -v ./...
      - go test -race -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html
    volumes:
      - name: test-cache
        path: /go/pkg

  # Step 3: Build and push service-a Docker image
  - name: build-push-service-a
    image: plugins/docker
    settings:
      registry: 192.168.253.133:5000
      repo: 192.168.253.133:5000/service-a
      tags:
        - latest
        - ${DRONE_COMMIT_SHA:0:8}
      context: services/service-a
      dockerfile: services/service-a/Dockerfile
      insecure: true
      build_args:
        - BUILDKIT_INLINE_CACHE=1
    volumes:
      - name: docker-sock
        path: /var/run/docker.sock
    depends_on:
      - test-service-a

  # Step 4: Build and push service-b Docker image
  - name: build-push-service-b
    image: plugins/docker
    settings:
      registry: 192.168.253.133:5000
      repo: 192.168.253.133:5000/service-b
      tags:
        - latest
        - ${DRONE_COMMIT_SHA:0:8}
      context: services/service-b
      dockerfile: services/service-b/Dockerfile
      insecure: true
      build_args:
        - BUILDKIT_INLINE_CACHE=1
    volumes:
      - name: docker-sock
        path: /var/run/docker.sock
    depends_on:
      - test-service-b

  # Step 5: Deploy to wg2
  - name: deploy-to-wg2
    image: alpine:latest
    environment:
      SSH_KEY:
        from_secret: ssh_private_key
      DEPLOY_USER: vagrant
    commands:
      # Install dependencies
      - apk add --no-cache openssh-client sshpass
      
      # Setup SSH key
      - mkdir -p ~/.ssh
      - echo "$SSH_KEY" > ~/.ssh/id_rsa
      - chmod 600 ~/.ssh/id_rsa
      - ssh-keyscan -H $WG2_HOST >> ~/.ssh/known_hosts
      
      # Deploy to wg2
      - |
        ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $DEPLOY_USER@$WG2_HOST << 'DEPLOY_SCRIPT'
        # Configure Docker for insecure registry
        echo '{"insecure-registries": ["$REGISTRY_HOST"]}' | sudo tee /etc/docker/daemon.json
        sudo systemctl restart docker
        sleep 5
        
        # Pull latest images
        sudo docker pull $REGISTRY_HOST/service-a:latest
        sudo docker pull $REGISTRY_HOST/service-b:latest
        
        # Stop and remove existing containers
        sudo docker stop service-a service-b 2>/dev/null || true
        sudo docker rm service-a service-b 2>/dev/null || true
        
        # Start new containers
        sudo docker run -d --name service-a --restart unless-stopped -p 8081:8080 $REGISTRY_HOST/service-a:latest
        sudo docker run -d --name service-b --restart unless-stopped -p 8082:8080 $REGISTRY_HOST/service-b:latest
        
        # Verify deployment
        sleep 3
        sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        echo "âœ… Deployment to wg2 completed successfully"
        DEPLOY_SCRIPT
    depends_on:
      - build-push-service-a
      - build-push-service-b

  # Step 6: Deploy to wg3
  - name: deploy-to-wg3
    image: alpine:latest
    environment:
      SSH_KEY:
        from_secret: ssh_private_key
      DEPLOY_USER: vagrant
    commands:
      # Install dependencies
      - apk add --no-cache openssh-client sshpass
      
      # Setup SSH key
      - mkdir -p ~/.ssh
      - echo "$SSH_KEY" > ~/.ssh/id_rsa
      - chmod 600 ~/.ssh/id_rsa
      - ssh-keyscan -H $WG3_HOST >> ~/.ssh/known_hosts
      
      # Deploy to wg3
      - |
        ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $DEPLOY_USER@$WG3_HOST << 'DEPLOY_SCRIPT'
        # Configure Docker for insecure registry
        echo '{"insecure-registries": ["$REGISTRY_HOST"]}' | sudo tee /etc/docker/daemon.json
        sudo systemctl restart docker
        sleep 5
        
        # Pull latest images
        sudo docker pull $REGISTRY_HOST/service-a:latest
        sudo docker pull $REGISTRY_HOST/service-b:latest
        
        # Stop and remove existing containers
        sudo docker stop service-a service-b 2>/dev/null || true
        sudo docker rm service-a service-b 2>/dev/null || true
        
        # Start new containers
        sudo docker run -d --name service-a --restart unless-stopped -p 8081:8080 $REGISTRY_HOST/service-a:latest
        sudo docker run -d --name service-b --restart unless-stopped -p 8082:8080 $REGISTRY_HOST/service-b:latest
        
        # Verify deployment
        sleep 3
        sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        echo "âœ… Deployment to wg3 completed successfully"
        DEPLOY_SCRIPT
    depends_on:
      - build-push-service-a
      - build-push-service-b

  # Step 7: Health check and notification
  - name: health-check
    image: alpine:latest
    commands:
      - apk add --no-cache curl
      # Test services via HAProxy
      - echo "ðŸ§ª Testing services via HAProxy..."
      - curl -f http://192.168.253.133:80/service-a || exit 1
      - curl -f http://192.168.253.133:80/service-b || exit 1
      - echo "âœ… All services are healthy and accessible via HAProxy"
      
      # Test direct access to backends
      - echo "ðŸ§ª Testing direct backend access..."
      - curl -f http://192.168.253.128:8081 || exit 1
      - curl -f http://192.168.253.128:8082 || exit 1
      - curl -f http://192.168.253.135:8081 || exit 1
      - curl -f http://192.168.253.135:8082 || exit 1
      - echo "âœ… All backend services are healthy"
      
      - echo "ðŸŽ‰ Deployment pipeline completed successfully!"
    depends_on:
      - deploy-to-wg2
      - deploy-to-wg3

# Pipeline volumes
volumes:
  - name: docker-sock
    host:
      path: /var/run/docker.sock
  - name: test-cache
    temp: {}

# Pipeline triggers
trigger:
  branch:
    - main
    - master
    - develop
  event:
    - push
    - pull_request

---
# Optional: Pipeline for feature branches (without deployment)
kind: pipeline
type: docker
name: feature-testing

steps:
  - name: test-only
    image: golang:1.21-alpine
    commands:
      - echo "Running tests for feature branch..."
      - cd services/service-a && go test -v ./...
      - cd ../service-b && go test -v ./...
      - echo "âœ… Feature branch tests passed"

trigger:
  branch:
    exclude:
      - main
      - master
      - develop
  event:
    - push
