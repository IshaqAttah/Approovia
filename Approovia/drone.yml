---
kind: pipeline
type: docker
name: multi-cloud-deployment

# Trigger configuration - only on push
trigger:
  branch:
    - main
    - master
  event:
    - push

# Global environment variables
environment:
  DOCKER_REGISTRY: 13.51.108.204:5000
  AWS_IP: 13.51.108.204
  GCP_IP: 34.88.69.228
  AWS_USER: ubuntu
  GCP_USER: ishaq.musa

# Pipeline steps
steps:
  # Step 1: Run unit tests for Service A
  - name: test-service-a
    image: golang:1.21-alpine
    commands:
      - cd services/service-a
      - go mod tidy
      - go test -v ./...
      - go vet ./...
      - gofmt -l .
    when:
      event:
        - push

  # Step 2: Run unit tests for Service B
  - name: test-service-b
    image: golang:1.21-alpine
    commands:
      - cd services/service-b
      - go mod tidy
      - go test -v ./...
      - go vet ./...
      - gofmt -l .
    when:
      event:
        - push

  # Step 3: Build Service A Docker image
  - name: build-service-a
    image: plugins/docker
    settings:
      registry: 13.51.108.204:5000
      repo: 13.51.108.204:5000/service-a
      tags:
        - latest
        - ${DRONE_COMMIT_SHA:0:8}
      dockerfile: services/service-a/Dockerfile
      context: services/service-a
      insecure: true
      platform: linux/amd64
    depends_on:
      - test-service-a
    when:
      event:
        - push
      branch:
        - main
        - master

  # Step 4: Build Service B Docker image
  - name: build-service-b
    image: plugins/docker
    settings:
      registry: 13.51.108.204:5000
      repo: 13.51.108.204:5000/service-b
      tags:
        - latest
        - ${DRONE_COMMIT_SHA:0:8}
      dockerfile: services/service-b/Dockerfile
      context: services/service-b
      insecure: true
      platform: linux/amd64
    depends_on:
      - test-service-b
    when:
      event:
        - push
      branch:
        - main
        - master

  # Step 5: Deploy to GCP (pull images and run containers)
  - name: deploy-to-gcp
    image: alpine:latest
    environment:
      GCP_SSH_KEY:
        from_secret: gcp_ssh_key
    commands:
      # Install dependencies
      - apk add --no-cache openssh-client curl
      
      # Setup SSH
      - mkdir -p ~/.ssh
      - echo "$GCP_SSH_KEY" > ~/.ssh/id_rsa
      - chmod 600 ~/.ssh/id_rsa
      - ssh-keyscan -H $GCP_IP >> ~/.ssh/known_hosts
      
      # Deploy to GCP
      - |
        ssh -i ~/.ssh/id_rsa $GCP_USER@$GCP_IP << 'EOF'
        # Configure Docker for insecure registry
        echo '{"insecure-registries": ["13.51.108.204:5000"]}' | sudo tee /etc/docker/daemon.json
        sudo systemctl restart docker
        sleep 5
        
        # Stop existing containers
        docker stop service-a service-b 2>/dev/null || true
        docker rm service-a service-b 2>/dev/null || true
        
        # Pull latest images
        docker pull 13.51.108.204:5000/service-a:latest
        docker pull 13.51.108.204:5000/service-b:latest
        
        # Create network if it doesn't exist
        docker network create services-network 2>/dev/null || true
        
        # Run Service A
        docker run -d \
          --name service-a \
          --network services-network \
          --restart unless-stopped \
          -p 8080:8080 \
          --health-cmd="wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1" \
          --health-interval=30s \
          --health-timeout=3s \
          --health-start-period=5s \
          --health-retries=3 \
          13.51.108.204:5000/service-a:latest
        
        # Run Service B
        docker run -d \
          --name service-b \
          --network services-network \
          --restart unless-stopped \
          -p 8081:8080 \
          --health-cmd="wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1" \
          --health-interval=30s \
          --health-timeout=3s \
          --health-start-period=5s \
          --health-retries=3 \
          13.51.108.204:5000/service-b:latest
        
        # Wait for services to be healthy
        echo "Waiting for services to become healthy..."
        sleep 30
        
        # Verify deployment
        docker ps --filter "name=service-"
        curl -f http://localhost:8080/health && echo "Service A is healthy"
        curl -f http://localhost:8081/health && echo "Service B is healthy"
        EOF
    depends_on:
      - build-service-a
      - build-service-b
    when:
      event:
        - push
      branch:
        - main
        - master

  # Step 6: Update HAProxy configuration (optional)
  - name: update-haproxy
    image: alpine:latest
    environment:
      AWS_SSH_KEY:
        from_secret: aws_ssh_key
    commands:
      # Install dependencies
      - apk add --no-cache openssh-client
      
      # Setup SSH
      - mkdir -p ~/.ssh
      - echo "$AWS_SSH_KEY" > ~/.ssh/id_rsa
      - chmod 600 ~/.ssh/id_rsa
      - ssh-keyscan -H $AWS_IP >> ~/.ssh/known_hosts
      
      # Restart HAProxy to ensure connectivity
      - |
        ssh -i ~/.ssh/id_rsa $AWS_USER@$AWS_IP << 'EOF'
        # Test connectivity to services
        curl -f http://34.88.69.228:8080/health || echo "Service A not ready"
        curl -f http://34.88.69.228:8081/health || echo "Service B not ready"
        
        # Restart HAProxy
        sudo systemctl restart haproxy
        sleep 5
        
        # Verify HAProxy is working
        curl -f http://localhost/service-a && echo "HAProxy -> Service A: OK"
        curl -f http://localhost/service-b && echo "HAProxy -> Service B: OK"
        EOF
    depends_on:
      - deploy-to-gcp
    when:
      event:
        - push
      branch:
        - main
        - master

  # Step 7: Integration tests
  - name: integration-tests
    image: alpine:latest
    commands:
      # Install curl
      - apk add --no-cache curl
      
      # Test services via HAProxy
      - echo "Testing services via HAProxy..."
      - curl -f http://$AWS_IP/service-a || exit 1
      - curl -f http://$GCP_IP:8080 || exit 1
      - curl -f http://$AWS_IP/service-b || exit 1
      - curl -f http://$GCP_IP:8081 || exit 1
      
      # Test HAProxy stats
      - curl -f http://$AWS_IP/stats || echo "Stats page not accessible"
      
      - echo "All integration tests passed!"
    depends_on:
      - update-haproxy
    when:
      event:
        - push
      branch:
        - main
        - master

  # Step 8: Notification (optional)
  - name: notify-success
    image: alpine:latest
    commands:
      - echo "  Deployment completed successfully!"
      - echo "Services available at:"
      - echo "  Service A: http://$AWS_IP/service-a"
      - echo "  Service B: http://$AWS_IP/service-b"
      - echo "  HAProxy Stats: http://$AWS_IP/stats"
    depends_on:
      - integration-tests
    when:
      event:
        - push
      branch:
        - main
        - master
      status:
        - success



